# Cursor Rules for Junie Project

## Core Principles
- **Clarity first**: readable code, meaningful names, short methods, simple control flow
- **Separation of concerns**: domain logic isolated from I/O, frameworks, and libraries
- **Functional Core, Imperative Shell**: keep service/domain layer pure (no I/O, no shared mutable state); perform side-effects only at API/data edges
- **Immutability by default**: prefer records and immutable DTOs, final fields, no setters, persistent/defensive copies
- **Testability**: unit tests for pure functions and services; integration tests for data/integration layer
- **Extensibility**: add new features by adding new packages/adapters rather than editing core logic
- **Explicit contracts**: define behavior at boundaries with interfaces and DTOs
- **Fail loud in dev, fail safe in prod**: clear exceptions in domain, defensive validation at edges
- **Functional programming style**: compose small pure functions, use map/filter/reduce and method references when they improve clarity, avoid side-effects inside pipelines

## Architecture (Simple Layered)
- **presentation/api** (imperative shell): entry points for external callers (CLI/REST/SDK, or simple facade). Side-effects live here (I/O, logging, environment, time)
- **service/use case** (functional core): application logic orchestrating operations using pure functions and immutable data
- **data/util** (imperative shell): persistence, HTTP, JSON, filesystem, or any external integrations

**Rules:**
- Keep dependencies one-way: presentation → service → data
- Prefer plain classes and interfaces; avoid over-engineering with extra indirections
- Keep layers thin and readable; move logic to the service layer
- Minimize shared state and mutation; pass values explicitly, return new values instead of mutating inputs

## Package-by-Topic Structure
Each topic gets its own top-level package under `dev.irako.topics.<topic>`. Inside the topic, use simple layers:
- `api` — optional facade/entry point
- `service` — use cases/business/application logic
- `data` — integrations (JSON, HTTP, DB, FS)
- `model` — DTOs and simple models used at boundaries
- `util` — topic-specific helpers (keep minimal)

Tests mirror the same structure under `src/test/java`.

## Design Patterns
- **Strategy**: choose between multiple algorithms/implementations at runtime
- **Factory/Abstract Factory**: construct data-layer integrations without exposing library types
- **Facade**: present a simple API to complex subsystems
- **Builder**: construct complex immutable objects
- **Functional composition**: prefer composing small pure functions over inheritance
- **Algebraic modeling**: use `record` classes for immutable data, `sealed` hierarchies for closed polymorphism, and `switch` pattern matching (Java 17+)
- **Template Method**: only if a fixed pipeline with overridable hooks is truly needed; prefer composition first

**Rule of thumb**: choose the simplest pattern that keeps code clear, immutable, and testable.

## Coding Standards

### Java Version & Style
- Java 17+; follow existing formatting of the module
- Prefer final fields and immutability

### Immutability
- Prefer `record` for DTOs and simple models; otherwise make fields `private final` and remove setters
- Return new instances instead of mutating parameters; use copy/with methods or builders for changes
- Avoid exposing mutable collections; use `List.copyOf`, `Map.copyOf`, or unmodifiable wrappers and defensive copies
- Avoid shared mutable state and static caches unless justified and well-synchronized

### Naming & Methods
- Names: nouns for classes, verbs for use cases, avoid abbreviations
- Methods: keep under ~20–30 lines; extract helpers if needed
- Favor pure functions (no observable side-effects) in the service layer
Ò
### Nulls & Errors
- Validate inputs at the API boundary
- Prefer `Optional` when it semantically models absence; avoid returning null
- Prefer explicit error modeling where appropriate
- Keep exceptions meaningful
- Service layer: prefer pure functions that either return a value or a domain error value
- Data layer: wrap third-party exceptions; never leak vendor types outside the data layer

### Logging
- Use SLF4J (`logger.debug/info/warn/error`)
- Keep logging out of core service logic when possible
- Primarily in api/data layers; levels appropriate

### Other
- Generics: keep type safety; avoid raw types
- Comments: explain "why", not "what"; keep comments sparse and accurate
- Use `var` only when the type is clear from the right-hand side; otherwise spell out the type
- Avoid wildcard imports; keep imports readable

## Junior-Friendly Guidelines
- **Prefer clarity over cleverness**: avoid cryptic one-liners and overly smart streams; break them into well-named steps
- **Choose explicit over implicit**: prefer clear variable names and method calls over magic or hidden behavior
- **Name things like you explain to a teammate**: methods are verbs (parseUser, validateInput, toDto), variables describe data (rawJson, userName, lines)
- **Keep functions small and single-purpose**: target ≤ 20–30 lines; extract helpers for distinct sub-steps
- **One level of abstraction per function**: do not mix parsing, validation, and I/O together
- **Control flow that's easy to follow**: prefer early guard clauses to reduce nesting; keep boolean logic straightforward
- **Comments that explain "why"**: add brief rationale for non-obvious decisions, trade-offs, or workarounds
- **Examples where non-obvious**: public APIs and tricky methods should include short usage example in Javadoc or tests
- **Make data and side-effects obvious**: default to immutable data; when mutation is required, isolate it and name it clearly
- **Errors that teach**: throw exceptions with actionable messages (what went wrong, which value, and how to fix)
- **Tests as living documentation**: write small, focused tests that demonstrate expected behavior and edge cases; name tests to read like a spec: methodName_condition_expectedResult

## Dependency Management (Gradle)
- Add libraries only in the layer that needs them (typically the data layer)
- Lock versions; prefer latest stable
- Test stack: JUnit 5, Mockito, AssertJ (add only when used)
- Do not add heavy frameworks unless a requirement demands it

## Workflow per Topic
1. **Requirement intake**: inputs/outputs defined with examples, error cases and constraints listed
2. **Design**: define services/use cases and data integrations; choose minimal pattern(s)
3. **Scaffold**: create the package `dev.irako.topics.<topic>` with `service`, `data`, optional `api`, and tests
4. **Implement**: service layer first with pure functions and immutable models; data layer second; api facade last
5. **Tests**: unit test services; integration test data layer with real libs where practical
6. **Wire dependencies** in Gradle (only needed ones)
7. **Demo** in `Main` or provide a small example in `api`
8. **Review** with the checklist and merge

## Review Checklist (Definition of Done)
- Architecture: simple layered structure (api → service → data) respected
- Tests: meaningful unit tests; data layer covered with integration tests where relevant
- Errors: exceptions clear; third-party exceptions wrapped in the data layer
- Logging: primarily in api/data layers; levels appropriate
- API: simple, minimal surface; good names
- Docs: Javadoc on public APIs; README or topic-level notes if non-obvious
- Build: Gradle compiles; tests run with `useJUnitPlatform()`
- Performance/security: obvious hotspots handled; inputs validated
- Immutability & Functional: service layer has no side-effects; models are immutable; no leaking mutable collections
- Junior-friendly: code and docs are understandable by a junior developer (clear names, small methods, comments about "why", and at least one usage example where non-obvious)

## Error Handling Policy
- Validate at the edges (api) and translate errors to checked outcomes as needed
- Service layer: prefer pure functions that either return a value or a domain error value
  - Option A (default): throw meaningful custom exceptions for truly exceptional situations
  - Option B (when it improves clarity): return a simple Result/Either-like type in the service layer to model expected failures without exceptions. Keep it in the service boundary; do not expose third-party types
- Data layer: wrap third-party exceptions; never leak vendor types outside the data layer
- When using exceptions, make them informative and avoid using them for control flow

## Performance & Memory
- Prefer streaming/iterators for large inputs (deserialization from streams)
- Avoid premature optimization; measure first when performance is a requirement
- Keep allocations reasonable; reuse `ObjectMapper`/clients via factories

## Security & Compliance
- Never log sensitive data
- Validate all external inputs
- Keep dependencies updated; avoid abandoned libraries

## Git & Commits
- Branch per topic: `feature/<topic>-short-description`
- Conventional Commits:
  - `feat(<topic>): add JSON deserializer`
  - `fix(<topic>): handle invalid input`
  - `test(<topic>): add adapter integration test`
  - `docs(<topic>): usage example`
- Small, focused commits tied to the use case

## When Implementing New Features
- Always follow the package-by-topic structure: `dev.irako.topics.<topic>`
- Start with service layer (pure functions), then data layer, then api facade
- Write tests alongside implementation
- Keep service layer free of side-effects and I/O
- Use immutable data structures (records, final fields, defensive copies)
- Validate inputs at API boundaries
- Wrap third-party exceptions in data layer
- Add Javadoc to public APIs with usage examples when non-obvious
